{
  "language": "Solidity",
  "sources": {
    "contracts/RepoRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract RepoRewards {\n\tstruct PoolManager {\n\t\tstring username;\n\t\tuint256 githubId;\n\t\tstring worldId;\n\t\taddress wallet;\n\t}\n\n\tstruct Contributor {\n\t\tstring username;\n\t\tuint256 githubId;\n\t\tstring worldId;\n\t\taddress wallet;\n\t}\n\n\tstruct Issue {\n\t\tuint256 issueId;\n\t\tuint256 rewardAmount;\n\t\tstring status;\n\t}\n\n\tstruct Repository {\n\t\taddress[] poolManagers;\n\t\taddress[] contributors;\n\t\tuint256 poolRewards;\n\t\tuint256 issueCount;\n\t\tmapping(uint256 => Issue) issueRewards;\n\t}\n\n\tmapping(address => PoolManager) public poolManagers;\n\tmapping(address => Contributor) public contributors;\n\tmapping(uint256 => Repository) public repositories;\n\n\taddress[] public poolManagerAddresses;\n\taddress[] public contributorAddresses;\n\taddress public admin;\n\n\tconstructor() {\n\t\tadmin = msg.sender;\n\t}\n\n\tmodifier onlyPoolManager(uint256 repoId) {\n\t\trequire(\n\t\t\tisPoolManager(repoId, msg.sender) || msg.sender == admin,\n\t\t\t\"Not authorized\"\n\t\t);\n\t\t_;\n\t}\n\n\tfunction isPoolManager(\n\t\tuint256 repoId,\n\t\taddress manager\n\t) internal view returns (bool) {\n\t\tRepository storage repo = repositories[repoId];\n\t\tfor (uint i = 0; i < repo.poolManagers.length; i++) {\n\t\t\tif (repo.poolManagers[i] == manager) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction registerUser(\n\t\tstring memory username,\n\t\tuint256 githubId,\n\t\tstring memory worldId,\n\t\tstring memory typeOfUser\n\t) external {\n\t\tif (\n\t\t\tkeccak256(abi.encodePacked(typeOfUser)) ==\n\t\t\tkeccak256(abi.encodePacked(\"PoolManager\"))\n\t\t) {\n\t\t\tpoolManagers[msg.sender] = PoolManager(\n\t\t\t\tusername,\n\t\t\t\tgithubId,\n\t\t\t\tworldId,\n\t\t\t\tmsg.sender\n\t\t\t);\n\t\t\tpoolManagerAddresses.push(msg.sender);\n\t\t} else {\n\t\t\tcontributors[msg.sender] = Contributor(\n\t\t\t\tusername,\n\t\t\t\tgithubId,\n\t\t\t\tworldId,\n\t\t\t\tmsg.sender\n\t\t\t);\n\t\t\tcontributorAddresses.push(msg.sender);\n\t\t}\n\t}\n\n\tfunction addPoolManager(\n\t\tuint256 repoId,\n\t\taddress poolManager,\n\t\tstring memory username,\n\t\tuint256 githubId\n\t) external onlyPoolManager(repoId) {\n\t\tRepository storage repo = repositories[repoId];\n\t\trepo.poolManagers.push(poolManager);\n\t\tpoolManagers[poolManager] = PoolManager(\n\t\t\tusername,\n\t\t\tgithubId,\n\t\t\t\"\",\n\t\t\tpoolManager\n\t\t);\n\t\tpoolManagerAddresses.push(poolManager);\n\t}\n\n\tfunction allocateIssueReward(\n\t\tuint256 repoId,\n\t\tuint256 issueId,\n\t\tuint256 reward\n\t) external onlyPoolManager(repoId) {\n\t\tRepository storage repo = repositories[repoId];\n\t\trequire(repo.poolRewards >= reward, \"Insufficient pool rewards\");\n\n\t\trepo.issueRewards[issueId] = Issue({\n\t\t\tissueId: issueId,\n\t\t\trewardAmount: reward,\n\t\t\tstatus: \"allocated\"\n\t\t});\n\n\t\trepo.issueCount++;\n\t\trepo.poolRewards -= reward;\n\t}\n\n\tfunction addFundToRepository(uint256 repoId) external payable {\n\t\tRepository storage repo = repositories[repoId];\n\t\tif (repo.poolManagers.length == 0) {\n\t\t\t// Create a new repository if it doesn't exist\n\t\t\trepositories[repoId].poolManagers = new address[](0);\n\t\t\trepositories[repoId].contributors = new address[](0);\n\t\t\t// Add the sender as the pool manager\n\t\t\trepositories[repoId].poolManagers.push(msg.sender);\n\t\t\tpoolManagerAddresses.push(msg.sender);\n\t\t}\n\t\trepositories[repoId].poolRewards += msg.value;\n\t}\n\n\tfunction distributeReward(\n\t\tuint256 repoId,\n\t\tuint256 issueId,\n\t\taddress payable contributorAddress\n\t) external onlyPoolManager(repoId) {\n\t\tRepository storage repo = repositories[repoId];\n\t\tIssue storage issue = repo.issueRewards[issueId];\n\t\tuint256 reward = issue.rewardAmount;\n\t\trequire(reward > 0, \"No reward allocated for this issue\");\n\t\tdelete repo.issueRewards[issueId];\n\t\trepo.issueCount--;\n\t\trequire(\n\t\t\taddress(this).balance >= reward,\n\t\t\t\"Insufficient contract balance\"\n\t\t);\n\n\t\t(bool success, ) = contributorAddress.call{ value: reward }(\"\");\n\t\trequire(success, \"Reward transfer failed\");\n\t}\n\n\treceive() external payable {}\n\n\tfunction getPoolManager(\n\t\taddress _wallet\n\t) external view returns (PoolManager memory) {\n\t\treturn poolManagers[_wallet];\n\t}\n\n\tfunction getContributor(\n\t\taddress _wallet\n\t) external view returns (Contributor memory) {\n\t\treturn contributors[_wallet];\n\t}\n\n\tfunction getRepository(\n\t\tuint256 _repoId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (address[] memory, address[] memory, uint256, Issue[] memory)\n\t{\n\t\tRepository storage repo = repositories[_repoId];\n\t\tIssue[] memory issues = new Issue[](repo.issueCount);\n\t\tuint counter = 0;\n\t\tfor (uint i = 0; i < repo.issueCount; i++) {\n\t\t\tif (repo.issueRewards[i].issueId != 0) {\n\t\t\t\tissues[counter] = repo.issueRewards[i];\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\treturn (repo.poolManagers, repo.contributors, repo.poolRewards, issues);\n\t}\n\n\tfunction getIssueRewards(\n\t\tuint256 repoId,\n\t\tuint256[] memory issueIds\n\t) external view returns (uint256[] memory) {\n\t\tRepository storage repo = repositories[repoId];\n\t\tuint256[] memory rewards = new uint256[](issueIds.length);\n\t\tfor (uint i = 0; i < issueIds.length; i++) {\n\t\t\trewards[i] = repo.issueRewards[issueIds[i]].rewardAmount;\n\t\t}\n\t\treturn rewards;\n\t}\n\n\tfunction checkUserType(\n\t\taddress _user\n\t) external view returns (string memory, address) {\n\t\tif (poolManagers[_user].wallet != address(0)) {\n\t\t\treturn (\"PoolManager\", _user);\n\t\t} else if (contributors[_user].wallet != address(0)) {\n\t\t\treturn (\"Contributor\", _user);\n\t\t} else {\n\t\t\treturn (\"User does not exist\", address(0));\n\t\t}\n\t}\n\n\tfunction getUserWalletByUsername(\n\t\tstring memory username\n\t) external view returns (address) {\n\t\tfor (uint i = 0; i < poolManagerAddresses.length; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\tpoolManagers[poolManagerAddresses[i]].username\n\t\t\t\t\t)\n\t\t\t\t) == keccak256(abi.encodePacked(username))\n\t\t\t) {\n\t\t\t\treturn poolManagers[poolManagerAddresses[i]].wallet;\n\t\t\t}\n\t\t}\n\t\tfor (uint i = 0; i < contributorAddresses.length; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\tcontributors[contributorAddresses[i]].username\n\t\t\t\t\t)\n\t\t\t\t) == keccak256(abi.encodePacked(username))\n\t\t\t) {\n\t\t\t\treturn contributors[contributorAddresses[i]].wallet;\n\t\t\t}\n\t\t}\n\t\treturn address(0);\n\t}\n\n\tfunction getRepositoryRewards(\n\t\tuint256[] memory repoIds\n\t) external view returns (uint256[] memory) {\n\t\tuint256[] memory rewards = new uint256[](repoIds.length);\n\t\tfor (uint i = 0; i < repoIds.length; i++) {\n\t\t\trewards[i] = repositories[repoIds[i]].poolRewards;\n\t\t}\n\t\treturn rewards;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}